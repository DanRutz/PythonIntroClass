\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[Intro to Python: Week 8]{Introduction  to Python\\
                                Decorators -- Debugging -- Packages and Packaging}
\author{Christopher Barker}
\institute{UW Continuing Education / Isilon}
\date{August 22, 2012}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

% ---------------------------------------------
\begin{frame}
  \titlepage
\end{frame}

% ---------------------------------------------
\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
  \tableofcontents
\end{frame}


\section{Review/Questions}

% ---------------------------------------------
\begin{frame}[fragile]{Review of Previous Class}

{\Large Lightning talk today: Peter}

\begin{itemize}
    \item Some more OO
    \begin{itemize}
      \item Multiple inheritance / mix-ins
      \item Properties
      \item \verb|staticmethod| and \verb|classmethod|
      \item Special methods (``dunder'')
    \end{itemize}
      \item Iterators
      \item Generators
\end{itemize}

\end{frame}


% header
% ---------------------------------------------
\begin{frame}[fragile]{Homework review}

{\Large Who added some classes to some ``real'' code?}

{\Large 
\begin{itemize}
      \item Multiple inheritance / mix-ins ?
      \item Property ?
      \item \verb|staticmethod| or \verb|classmethod| ?
      \item Special methods ?
      \item Iterator or Generators ?
\end{itemize}
}
\end{frame}

\section{Decorators}

% ---------------------------------------------
\begin{frame}[fragile]{Decorators}

{\LARGE Decorators are wrappers around functions}

\vfill
{\LARGE They let you add code before an after the execution of a function}

\vfill
{\LARGE Creating a custom version of that function}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Decorators}

{\LARGE Syntax:}

\vfill
\begin{verbatim}
@logged
def add(a, b):
    """add() adds things"""
    return a + b
\end{verbatim}

\vfill
{\Large Demo and Motivation: \verb|basicmath.py| }

\vfill
PEP: \url{http://www.python.org/dev/peps/pep-0318/}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Decorators}

{\LARGE \verb|@| decorator operator is an abbreviation:}

\vfill
\begin{verbatim}
@f
def g:
    pass
\end{verbatim}

\vfill
same as

\vfill
\begin{verbatim}
def g:
    pass
g = f(g)
\end{verbatim}

\vfill
{\Large ``Syntactic Sugar'' -- but really quite nice}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Decorators}

{\LARGE demo:

\vfill
\begin{verbatim}
memoize.py
\end{verbatim}

}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Decorator  examples}

{\LARGE Examples from the stdlib:}

\vfill
{\Large Does this structure:}

\vfill
\begin{verbatim}
def g:
    pass
g = f(g)
\end{verbatim}

\vfill

{\Large look familiar from last class?}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Decorator examples}

{\LARGE \verb|staticmethod()|}

\vfill
\begin{verbatim}
￼class C(object):
    def add(a, b):
        return a + b
    add = staticmethod(add)
\end{verbatim}

\vfill

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Decorator examples}

{\LARGE \verb|staticmethod()|}

\vfill
{\Large Decorator form:}
\begin{verbatim}
￼class C(object):
    @staticmethod
    def add(a, b):
        return a + b
\end{verbatim}

\vfill

{\LARGE ( and \verb|classmethod| )}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{examples}

{\LARGE \verb|property()|}

\vfill
\begin{verbatim}
￼￼class C(object):
    def __init__(self):
        self._x = None
    def getx(self):
        return self._x
    def setx(self, value):
        self._x = value
    def delx(self):
        del self._x
    x = property(getx, setx, delx,
                 "I'm the 'x' property.")
\end{verbatim}

\vfill
becomes...
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Decorator examples}

\begin{verbatim}
class C(object):
    def __init__(self):
        self._x = None
    @property
    def x(self):
        return self._x
    @x.setter
    def x(self, value):
        self._x = value
    @x.deleter
    def x(self):
        del self._x
\end{verbatim}

\vfill
Puts the info close to where it is used
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{examples}

{\LARGE CherryPy}

\vfill
\begin{verbatim}
import cherrypy
class HelloWorld(object):
    @cherrypy.expose
    def index(self):
        return "Hello World!"
cherrypy.quickstart(HelloWorld())
\end{verbatim}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{examples}

{\LARGE Pyramid}

\vfill
\begin{verbatim}

@template
def A_view_function(request)
   .....
@json
def A_view_function(request)
   ......


\end{verbatim}

so you don't need to think about what your view is returning...

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{decorators...}

{\Large For this class:}

\vfill
{\Large Mostly want to you to know how to use decorators that someone else has written}

\vfill
{\Large Have a basic idea what they do when you do use them}

\end{frame} 


%-------------------------------
\begin{frame}[fragile]{LAB}

\begin{itemize}
  \item Re-write the properties from last week's \verb|Circle| class to use the
        decorator syntax (see a couple slides back for an example)

  \item Write a decorator that can be used to wrap any function that returns a
        string in a \verb|<p>| element from the html builder from the previous
        couple classes (the \verb|P Element| subclass).
\end{itemize}

\end{frame}

% Lightning Talk Slide
%-------------------------------
\begin{frame}{Lightning Talk}

{\centering

\vfill
{\LARGE Lightning Talk:  }

\vfill
{\Huge Peter}

\vfill
}
\end{frame}


\section{Debugging}

% ---------------------------------------------
\begin{frame}[fragile]{Debugging}

{\LARGE Debugging}

\vfill
{\Large Debugging is a methodical process of finding and reducing the number
of bugs, or defects, in a computer program}

\vfill
{\Large We often spend more time debugging that we do writing the code in the
first place}

\end{frame} 

\begin{frame}[fragile]{Debugging}

{\LARGE Core Message:}

\vfill
{\Large Well structured code is less prone to bugs}

\vfill
{\Large Well structured code is easier to debug}


\end{frame} 

\begin{frame}[fragile]{Types of Bugs}

{\LARGE

\begin{itemize}
\item Syntax Errors
\item Run Time Errors
\item Logic Errors
\end{itemize}
}

\vfill
(Usually show up in that order)
\end{frame} 

\begin{frame}[fragile]{Syntax Errors}

{\LARGE Common Causes}

\begin{itemize}
\item Mismatched parenthesis, quotes, brackets, etc...
\item Missing colons
\item ``='' vs ``==''
\item Indentation
\item Using a keyword for a variable name
\end{itemize}

\vfill
Hint: Make sure you are editing the same file you are running!
\end{frame} 

\begin{frame}[fragile]{Runtime Errors}

{\LARGE This may seem obvious, but...}

\vfill
{\Large Read the traceback carefully!}

\begin{itemize}
  \item What type of error?
  \begin{itemize}
    \item ValueError
    \item TypeError
    \item NameError
    \item Think about what that type of error means
  \end{itemize}
  \item What module/function did it occur in?
  \item What line did it occur?
  \item Where was that function called from?
\end{itemize}
\end{frame} 

\begin{frame}[fragile]{Logic Errors}

{\LARGE No hints from the interpreter}

\vfill
\begin{itemize}
  \item Make sure the code you think is executing is really executing
  \item Simplify your code
  \item Boil it down to the simplest version that shows the bug
  \begin{itemize}
    \item Often you'll find it in the process
  \end{itemize}
  \item Save (and print) intermediate results from long expressions
  \item Try out bits of code at the command line (or iPython)
\end{itemize}

\end{frame} 

\begin{frame}[fragile]{Debugging Tools}

{\LARGE
\vfill
Print statements
\vfill
Interactive debuggers
\vfill
Logging
\vfill
Tests
}
\end{frame} 

\begin{frame}[fragile]{Print Statements}

{\LARGE
\vfill
Simple
\vfill
Easy to understand
\vfill
Quick (with no compile cycle)
\vfill
Nice if something fails the 1000th time through a loop...
}
\vfill
( I do most of my debugging with print statements )
\end{frame} 

\begin{frame}[fragile]{Logging}

{\LARGE ￼``enterprise level print statements''}

\vfill
Standard library logging module

\vfill
powerful, awesome, and a bit annoying

\vfill
\url{http://docs.python.org/library/logging.html}
\url{http://docs.python.org/howto/logging.html#logging-basic-tutorial}

\end{frame} 

\begin{frame}[fragile]{Logging Module}

{\LARGE Using the standard module means you can share your logging with third
party packages, etc.}

\vfill
\begin{itemize}
  \item Customized levels
  \item String interpolation
  \item On the fly configuration
  \item etc, etc..
\end{itemize}

\end{frame} 

\begin{frame}[fragile]{Logging Module}

{\LARGE ￼Output options:}

\vfill
\begin{itemize}
\item StreamHandler 
\item FileHandler 
\item BaseRotatingHandler 
\item RotatingFileHandler 
\item TimedRotatingFileHandler 
\item SocketHandler 
\item SMTPHandler 
\item SysLogHandler 
\item HTTPHandler 
\item NullHandler 
\item ...
\end{itemize}

\end{frame} 


\begin{frame}[fragile]{Tests}

{\LARGE Test Suites Find Bugs}

\vfill
{\LARGE And keep them from recurring}

\vfill
{\LARGE You can get closer to the bug by writing more tests}

\end{frame} 

\begin{frame}[fragile]{Tests}

{\LARGE Test Suites are particularly helpful for Heisenbugs:}

\vfill
heisenbug: /hi-zen-buhg/, n.\\[0.1in]
A bug that disappears or alters its behavior when one attempts to probe or isolate it.

\vfill
\url{http://www.catb.org/jargon/html/H/heisenbug.html}

\vfill
{\Large More on testing next class}

\end{frame} 


\begin{frame}[fragile]{Interactive Debuggers}

{\LARGE PDB}

\vfill
{\Large
\begin{itemize}
\item in stdlib
\item command line
\item local
\item in process
\end{itemize}
}

\end{frame} 

\begin{frame}[fragile]{PDB}

( I've never used any of these much -- but ...)

\vfill
{\Large Getting started with pdb (blog post):}

\url{http://pythonconquerstheuniverse.wordpress.com/2009/09/10/debugging-in-python/}\\
(Nice simple intro)

\vfill
{\Large Python Debugging Techniques}
\url{http://aymanh.com/python-debugging-techniques}

\vfill
{\Large Use pdb to debug Django (screencast):}
\url{http://ericholscher.com/blog/2008/aug/31/using-pdb-python-debugger-django-debugging-series-/}

\end{frame} 




%-------------------------------
\begin{frame}{LAB}

{\Large PDB lab}

\begin{itemize}
  \item
\end{itemize}

\end{frame}


\section{Packages and Packaging}

% ---------------------------------------------
\begin{frame}[fragile]{Modules and Packages}

\vfill
{\Large A module is a file with python code in it}

\vfill
{\Large A package is a directory with and \verb|__init__.py| file in it}

\vfill
{\Large And usually other modules, packages, etc...}

\begin{verbatim}
my_package
    __init__.py
    module_a.py
    module_b.py
\end{verbatim}

\begin{verbatim}
    import my_package
\end{verbatim}

runs \verb|my_package/__init__.py|

\begin{verbatim}
    import my_package.module_a
\end{verbatim}

runs \verb|my_package/__init__.py| and \verb|my_package.module_a.py|

\end{frame} 


% ---------------------------------------------
\begin{frame}[fragile]{Modules and Packages}

\vfill
\begin{verbatim}
import sys

for p in sys.path:
    print p

\end{verbatim}

\vfill
(demo)
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Installing Python}

{\Large Linux:}

Usually part of the system -- just use it

\vfill
{\Large Windows:}

\vfill
Use the \url{python.org} version:

\vfill
System Wide

\vfill
Can install multiple versions if need be

\vfill
Third party binaries for it.

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Installing Python}

{\Large OS-X:}

Comes with the system, but:
\begin{itemize}
    \item Apple has never upgraded within a release
    \item There are non-open source components
    \item Third party packages may or may not support it
    \item Apple does use it -- so don't mess with it.
    \item I usually recommend the \url{python.org} version
\end{itemize}
(Also Macports, Fink, Home Brew...)

\vfill
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Installing Packages}

{\Large Every Python installation has its own stdlib and \verb|site-packages| folder}

\vfill
{\Large\verb|site-packages| is the default place for third-party packages}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Finding Packages}

{\Large The Python Package Index:}

\vfill
{\LARGE PyPi}

\vfill
\url{http://pypi.python.org/pypi}

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{Installing Packages}

{\Large From source}
(\verb|setup.py install|)

\vfill
{\Large With the system installer (apt-get, yum, etc...)}

\vfill
{\Large From binaries: }

\vfill
{\Large Windows: MSI installers}

\vfill
{\Large OS-X: dmg installers }

(make sure to get compatible packages)

\vfill
{\Large \verb|easy_install| and \verb|pip|}

\end{frame} 



%-------------------------------
\begin{frame}{LAB}

\begin{itemize}
  \item
\end{itemize}

\end{frame}

%-------------------------------
\begin{frame}{Wrap up}

\begin{itemize}
  \item
\end{itemize}

\end{frame}



%-------------------------------
\begin{frame}{Homework}

\begin{itemize}
  \item
\end{itemize}

\end{frame}


\end{document}

 
