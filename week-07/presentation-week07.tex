\documentclass{beamer}
%\usepackage[latin1]{inputenc}
\usetheme{Warsaw}
\title[Intro to Python: Week 7]{Introduction  to Python\\ More OO -- Decorators and Generators}
\author{Christopher Barker}
\institute{UW Continuing Education / Isilon}
\date{August 08, 2012}

\usepackage{listings}
\usepackage{hyperref}

\begin{document}

% ---------------------------------------------
\begin{frame}
  \titlepage
\end{frame}

% ---------------------------------------------
\begin{frame}
\frametitle{Table of Contents}
%\tableofcontents[currentsection]
  \tableofcontents
\end{frame}


\section{Review/Questions}

% ---------------------------------------------
\begin{frame}[fragile]{Review of Previous Class}

\begin{itemize}
  \item Really Quick OO overview
  \item Built an html generator, using: 
  \begin{itemize}
    \item A base class with a couple methods
    \item Subclasses overriding class attributes
    \item Subclasses overriding a method
    \item Subclasses overriding the \verb|__init__|
  \end{itemize}
\end{itemize}

\end{frame}


% header
% ---------------------------------------------
\begin{frame}{Homework review}

  {\Large Homework notes }

\end{frame}

\section{More OO}

% ---------------------------------------------
\begin{frame}[fragile]{multiple inheritance}

{\Large Multiple inheritance:\\
\hspace{0.2in} Pulling from more than one class}

\vfill
\begin{verbatim}
class Combined(Super1, Super2, Super3):
    def __init__(self, something, something else):
        Super1.__init__(self, ......)        
        Super2.__init__(self, ......)        
        Super3.__init__(self, ......)        
\end{verbatim}
(calls to the super class \verb|__init__| are optional -- case dependent)

\vfill
{\Large Attribute resolution -- left to right}

\vfill
( Why would you want to do this? )

\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{mix-ins}

\vfill
{\Large Hierarchies are not always simple}
\vfill
\begin{itemize}
  \item Animal
  \begin{itemize}
    \item Mammal
    \begin{itemize}
      \item GiveBirth()
    \end{itemize}
    \item Bird
    \begin{itemize}
      \item LayEggs()
    \end{itemize}
  \end{itemize}
\end{itemize}
\vfill
{\Large Where do you put a Platypus or an Armadillo?}

\vfill
{\Large Real World Example: \verb|FloatCanvas|}
\end{frame} 

% ---------------------------------------------
\begin{frame}[fragile]{properties}

{\Large Simple attributes:}

\begin{verbatim}
In [5]: class C(object):
        def __init__(self):
                self.x = 5
In [6]: c = C()
In [7]: c.x
Out[7]: 5
In [8]: c.x = 8
In [9]: c.x
Out[9]: 8
\end{verbatim}

\end{frame} 



\section{Special Methods}


\section{Iterators / Generators}

% ---------------------------------------------
\begin{frame}[fragile]{Iterators}

{\Large Iterators are one of the main reasons Python code is so readable:}

\begin{verbatim}
for x in just_about_anything:
    do_stuff(x)
\end{verbatim}

{\Large you can loop through anything that satisfies the iterator protocol}

\vfill
\url{http://docs.python.org/library/stdtypes.html#iterator-types}
\end{frame} 

\begin{frame}[fragile]{Iterator Protocol}

{\Large An iterator must have the following methods:}

\begin{verbatim}
iterator.__iter__()
\end{verbatim}

Return the iterator object itself. This is required to allow both containers
and iterators to be used with the for and in statements.

\begin{verbatim}
iterator.next()
\end{verbatim}

Return the next item from the container. If there are no further items,
raise the StopIteration exception.

\end{frame} 


\begin{frame}[fragile]{Example Iterator}

\begin{verbatim}
class IterateMe_1(object):
    def __init__(self, stop=5):
        self.current = 0
        self.stop = 5
    def __iter__(self):
        return self
    def next(self):
        if self.current < self.stop:
            self.current += 1
            return self.current
        else:
            raise StopIteration
\end{verbatim}

{\Large This is a simple version of \verb|xrange()|}

\end{frame} 

%%-------------------------------
\begin{frame}[fragile]{LAB}

\begin{itemize}
  \item  Extend (\verb|iterator_1.py|) to be more like \verb|xrange()| --
         add three input parameters: \verb|iterator_2(start, stop, step=1)|
  \item  See what happens if you break out in the middle of the loop:
\begin{verbatim}
    it = IterateMe_2(2, 20, 2)
    for i in it:
        if i > 10:  break
        print i
\end{verbatim}
And then pick up again:
\begin{verbatim}
    for i in it:
        print i
\end{verbatim}
  \item  Does \verb|xrange()| behave the same?\\
          -- make yours match \verb|xrange()|.
\end{itemize}

\end{frame}


\end{document}

 
